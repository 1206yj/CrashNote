[TOC]

# 二、彩色图像处理

## 1. 颜色的特性

- 亮度：光的振幅，物体表面的反光率。实际上不能度量，色彩的强度（人眼对亮度的敏感 > 色彩）
- 色调：人感知的主要颜色
  补色：**两个颜色相加是白色**，则互为补色（在色环上，与一个色调直接相对的另一端），让颜色**变亮**不是加白，是**减去补色**，这样**色调才不会改变**（用于增强图像暗区细节）
- 饱和度：颜色的纯度，一种颜色混合白色的比例（100% 是无白光混合），物体反射的颜色，**饱和度高了色彩会鲜亮**
- 色度：色调 + 饱和度
  ​

## 2. 色彩模型

### 2.1 RGB 色彩模型

特点：适合色彩生成，适合硬件设备对于色彩的实现

加色混色模型：颜色混在一起亮度增大，**R**ed、**G**reen、**B**lue 三种颜色的取值范围是 [0, 255]

![](/Users/sun/Documents/CrushNote/DigitalImageProcessing/images/modelRGB.png)

### 2.2 CMY 和 CMYK 色彩模型 	 

特点：适合色彩生成，适合硬件设备对于色彩的实现

减色混色模型：颜色混在一起亮度降低，**C**yan (青)、**M**agenta (品红)、**Y**ellow(黄)、Blac**K**(黑)，加入黑色是因为打印时由品红、黄、青构成的黑色不够纯粹

![](/Users/sun/Documents/CrushNote/DigitalImageProcessing/images/modelCMYK.png)



### 2.3 HSI、HSL 和 HSV 色彩模型 

特点：适合色彩描述、电脑绘画、图像算法的处理，人能观察的色彩并不是由 RGB 三种颜色混合而成，而是取决于颜色的亮度、色调、饱和度。**HSI、HSL、HSV 方便和RGB 进行互相转换**

#### 2.3.1 关键概念

- **H**ue：色相，决定什么颜色，对应 **红 (0°) 绿(120°) 蓝(240°)** 首尾相接的色相环值，取值范围 [0, 360)
- **S**aturation：饱和度，决定颜色浓淡，一种颜色混合白光的比例（100% 是无白光混合），物体反射的颜色，**饱和度高了色彩会鲜亮**
- **V**alue/**L**ightness：明度，光源的明暗，人们所感知到的色彩明暗度
- Brightness/Luminance/Intensity：亮度，光的振幅，物体表面的反光率，表面色彩白色的多少
- Chroma：色度 = 色相(方向) + 饱和度(大小)，一种颜色混合白光的比例（100% 是无白光混合）

#### 2.3.2 各自的特点

HSI 主要用于方便处理图片色彩，而非用于修改和选择颜色
HSL 和 HSV 有相同的灰度定义，但在 饱和度 和 亮度的定义方面是不同的：

- 亮度：HSL 最大为 0.5，HSV 最大为 1
- 饱和度：饱和度为 1 时，HSL 亮度为 0.5，HSV 亮度为 1


明度和亮度：都决定照射在颜色上的白光有多亮，亮度与颜色的辐射能量有关，但能量高的颜色不一定明度高。例，蓝色的能量很高，但其明度却低 [more](https://en.wikipedia.org/wiki/HSL_and_HSV)

HSL、HSV 缺点：

- 在高色度上的亮度相对于 YUV 偏离过多
- 在选择颜色和配色方案上存在问题

![](/Users/sun/Documents/CrushNote/DigitalImageProcessing/images/modelHSLV.png)

#### 2.3.3 公式推导

从 RGB 到 HSI 或 HSL 或 HSV 的 Hue 是由 RGB 的如下整投影得到的：

- M：max(R, G, B) 、m：min(R, G, B)、C：色度 = M - m

![](/Users/sun/Documents/CrushNote/DigitalImageProcessing/images/HSL_HSV_hue_and_chroma.svg)

- I: HSI 里的 I，Y'：YUV 里的灰度值
  ![](/Users/sun/Documents/CrushNote/DigitalImageProcessing/images/Hsl_hsv_chroma-lightness_slices.svg)

### 2.3 YUV 和 YCbCr 色彩模型

特点：适合电视系统，数码摄影点色彩生成和传输

- YUV：Y (亮度)、UV (色度)，欧洲电视系统色彩模型 PAL 制式 
- YCbCr：Y (亮度)、Cb (蓝色色度)、Cr (红色色度)，**YUV 的压缩和偏移版本**

## 3. 色彩模型间的互相转换
### 3.1 RGB 与 CMY

- 公式：假设所有彩色值都归一化到了 [0, 1] 的范围内
  ​
  $$
  \begin{bmatrix}
  C\\
  M\\
  Y
  \end{bmatrix}
  =
  \begin{bmatrix}
  1\\
  1\\
  1
  \end{bmatrix}
  - 
  \begin{bmatrix}
  R\\
  G\\
  B
  \end{bmatrix}
  $$



### 3.2 RGB 与 HSL 

**RGB 转 HSL**

- 公式：
  如果 R = G = B 时，颜色是非彩色的，H (色相) 无定义，H = S = 0
  max 是 R、G、B 中的最大值
  min  是 R、G、B 中的最小值

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 360), S \in [0,1], L \in [0,1]$
  ​
  $$
  \begin{aligned}

  H &= 
  \begin{cases}
  0, &\text{if max = min}\\
  {G - B \over max - min} \times 60  , &\text{if max = R  and G $\geq$ B} \\
  {G - B \over max - min} \times 60  + 360, &\text{if max = R  and G $\lt$ B}\\
  {B - R \over max - min} \times 60  + 120, &\text{if max = G}\\
  {R - G \over max - min} \times 60  + 240, &\text{if max = B} \\
  \end{cases} \\\\
  L &= \frac 12(max + min) \\\\
  S & = 
  \begin{cases}
  0 , &\text{if max = min or L = 1}\\
  {max - min \over 1 - |2L - 1|}  , &\text{otherwise}
  \end{cases} 
  \end{aligned}
  $$

- 代码：

  ```c
  // GLSL
  vec3 RGBToHSL(vec3 color) {
      float minRGB = min(min(color.r, color.g), color.b);
      float maxRGB = max(max(color.r, color.g), color.b);
      float sum = maxRGB + minRGB;
      float chroma = maxRGB - minRGB;
      float luminance = 0.5 * sum;

      vec3 hsl = vec3(0.0, 0.0, luminance);
   
      if (chroma == 0.0) return hsl; // R = G = B, 颜色是非彩色的 S = 0，这是色相无定义 H = 0

      // Saturation
      hsl.y = luminance == 1.0 ? 0.0 : chroma / (1.0 - abs(2.0 * luminance - 1.0));
      
      // Hue 原来范围是 [0, 360), 这里默认输入的范围是 [0, 1]
      /** 尽管这样并不能真的提高效率，但是这个规避 if else 的思想值得思考 
          vec3 comp;
          comp.rg = vec2(equal(rgb.rg, vec2(maxRGB)));
          float invertR = 1.0 - comp.r;       // 0 or 1
          comp.g *= invertR;                  // g = invertR * g
          comp.b  = invertR * (1.0 - comp.g); // b = invertR * invertG
          hsl.x = dot(comp, vec3((color.g - color.b) / chroma, (color.b - color.r) / chroma + 2.0, (color.r - color.g) / chroma + 4.0));
          hsl.x /= 6.0;
      */
      if (color.r == maxRGB) {
          hsl.x =  (color.g - color.b) / chroma / 6.0;         
      } else if (color.g == maxRGB) {
          hsl.x = ((color.b - color.r) / chroma + 2.0) / 6.0; 
      } else {
          hsl.x = ((color.r - color.g) / chroma + 4.0) / 6.0; 
      }
  	
      // Optimize
      // hsl.x += 1.0 - step(0.0, hsl.x);
      if (hsl.x < 0.0) hsl.x += 1.0; 
      
      return hsl;
  }
  ```

**HSL 转 RGB**
- 公式：
  如果 S (饱和度)  = 0，则颜色是非彩色的。H (色相)无意义， R = G = B = L (亮度)
  如果 S (饱和度) != 0，有如下公式

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 360), S \in [0,1], L \in [0,1]$
  > H' 取整数时，两边计算结果相同
  $$
  \begin{aligned}
  H' &= {H \over 60}\\
  C &= (1 - |2L - 1|) \times S \\
  X &=  (1 - |H' \pmod 2 - 1|)\times C \\
  m &= L - \frac 12 C \\\\
  (R, G, B) &= 
  \begin{cases}
  (C + m, X + m,  m), &\text{if $0 \leq H' \leq 1$}\\
  (X + m, C + m,  m), &\text{if $1 \leq H' \leq 2$} \\
  (m, C + m,  X + m), &\text{if $2 \leq H' \leq 3$} \\
  (m, X + m,  C + m), &\text{if $3 \leq H' \leq 4$} \\
  (X + m, m,  C + m), &\text{if $4 \leq H' \leq 5$} \\
  (C + m, m,  X + m), &\text{if $5 \leq H' \lt 6$} \\
  \end{cases}\\
  \end{aligned}
  $$

- 代码：
```c
vec3 HSLToRGB(vec3 color) {
    if (color.y == 0.0) return vec3(color.z); // Luminance
    
    float hue = color.x;
    hue *= 6.0; 					  // Hue 默认范围是 [0, 1]
    float chroma = (1.0 - abs(2.0 * color.z - 1.0)) * color.y;
    float m = color.z - 0.5 * chroma; // Lightness
    float x = (1.0 - abs(mod(hue, 2.0) - 1.0)) * chroma;
    
    if (hue < 1.0){
        return vec3(chroma + m, x + m, m);
    } else if (hue < 2.0){
        return vec3(x + m, chroma + m, m);
    } else if (hue < 3.0){
    	return vec3(m, chroma + m, x + m);
    } else if (hue < 4.0){
        return vec3(m, x + m, chroma + m);        
    } else if (hue < 5.0){
        return vec3(x + m, m, chroma + m);
    } else {
        return vec3(chroma + m, m, x + m);
    }
}
```

### 3.3 RGB 与 HSV 

**RGB 转 HSV**

- 公式：
  如果 R = G = B 时，颜色是非彩色的，H (色相) 无定义，H = S = 0
  max 是 R、G、B 中的最大值
  min  是 R、G、B 中的最小值

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 360), S \in [0,1], V \in [0,1]$

$$
\begin{aligned}

H &= 
\begin{cases}
0, &\text{if max = min}\\
{G - B \over max - min} \times 60  , &\text{if max = R  and G $\geq$ B} \\
{G - B \over max - min} \times 60  + 360, &\text{if max = R  and G $\lt$ B}\\
{B - R \over max - min} \times 60  + 120, &\text{if max = G}\\
{R - G \over max - min} \times 60  + 240, &\text{if max = B} \\
\end{cases} \\\\
S & = 
\begin{cases}
0 , &\text{if max = 0}\\
{max - min \over max}, &\text{if max $\neq 0$}
\end{cases} \\\\
V &= max
\end{aligned}
$$

- 代码：

 ```c
// GLSL
vec3 RGBToHSV(vec3 color) {
	float minRGB = min(min(color.r, color.g), color.b);
    float maxRGB = max(max(color.r, color.g), color.b);
    float sum = maxRGB + minRGB;
    float chroma = maxRGB - minRGB;
    
    // V = maxRGB;
    vec3 hsv = vec3(0.0, 0.0, maxRGB);
    if (chroma == 0.0) return hsv;
    
    // Saturation
    hsv.y = maxRGB == 0.0 ? 0.0 : chroma / maxRGB;
    
    // Hue 原来范围是 [0, 360), 这里默认输入的范围是 [0, 1]
    if (color.r == maxRGB) {
        hsv.x =  (color.g - color.b) / chroma / 6.0;         
    } else if (color.g == maxRGB) {
        hsv.x = ((color.b - color.r) / chroma + 2.0) / 6.0; 
    } else {
        hsv.x = ((color.r - color.g) / chroma + 4.0) / 6.0; 
    }
   
    // Optimize
    // hsv.x += 1.0 - step(0.0, hsv.x);
    if (hsv.x < 0.0) hsv.x += 1.0; 
    
    return hsv;
}
 ```

**HSV 转 RGB**

- 公式：
  如果 S (饱和度)  = 0，则颜色是非彩色的。H (色相)无意义， R = G = B = L (亮度)如果 S (饱和度) != 0，有如下公式

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 360), S \in [0,1], V \in [0,1]$
  ​
  $$
  \begin{aligned}
  H' &= {H \over 60}\\
  C &= V \times S \\
  X &=  (1 - |H' \pmod 2 - 1|)\times C \\
  m &= V - C \\\\
  (R, G, B) &= 
  \begin{cases}
  (C + m, X + m,  m), &\text{if $0 \leq H' \leq 1$}\\
  (X + m, C + m,  m), &\text{if $1 \leq H' \leq 2$} \\
  (m, C + m,  X + m), &\text{if $2 \leq H' \leq 3$} \\
  (m, X + m,  C + m), &\text{if $3 \leq H' \leq 4$} \\
  (X + m, m,  C + m), &\text{if $4 \leq H' \leq 5$} \\
  (C + m, m,  X + m), &\text{if $5 \leq H' \lt 6$} \\
  \end{cases}\\
  \end{aligned}
  $$
  > **⌊ ⌋ Floor    向下取整：** 比自己小的最大整数，舍弃小数位
  > **⌈ ⌉ Ceiling 向上取整：** 比自己大的最小整数，有小数位就进 1
  > $\equiv$ ：
  >
  > 1. 恒等号 一般用于一些参变量恒为一个常数或恒定表达式时，总等于关系与变量无关。例 $f(x) \equiv k，f(x)$ 的值始终为 k 而与 x 无关
  > 2. 同余符号，例 $a \equiv b \pmod c$ ，a 和 b 分别除以 c 得到的余数相同

- 代码：
 ```c
// GLSL
vec3 HSVToRGB(vec3 color) { 
    if (color.y == 0.0) return vec3(color.z); // Luminance
    
    float hue = color.x;
    hue *= 6.0; 			     // Hue 默认范围是 [0, 1]
    float chroma = color.z * color.y;
    float m = color.z - chroma;  // Lightness
    float x = (1.0 - abs(mod(hue, 2.0) - 1.0)) * chroma;
    
    if (hue < 1.0){
        return vec3(chroma + m, x + m, m);
    } else if (hue < 2.0){
        return vec3(x + m, chroma + m, m);
    } else if (hue < 3.0){
    	return vec3(m, chroma + m, x + m);
    } else if (hue < 4.0){
        return vec3(m, x + m, chroma + m);        
    } else if (hue < 5.0){
        return vec3(x + m, m, chroma + m);
    } else {
        return vec3(chroma + m, m, x + m);
    }
}
 ```

### 3.4 RGB 与 HSI 

**RGB 转 HSI**

- 公式：
  如果 R = G = B 时，颜色是非彩色的，H (色相) 无定义，H = S = 0
  max 是 R、G、B 中的最大值
  min  是 R、G、B 中的最小值

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 360), S \in [0,1], I \in [0,1]$
  ​
  $$
  \begin{aligned}
  H &= 
  \begin{cases}
  0, &\text{if max = min}\\
  {G - B \over max - min} \times 60  , &\text{if max = R  and G $\geq$ B} \\
  {G - B \over max - min} \times 60  + 360, &\text{if max = R  and G $\lt$ B}\\
  {B - R \over max - min} \times 60  + 120, &\text{if max = G}\\
  {R - G \over max - min} \times 60  + 240, &\text{if max = B} \\
  \end{cases} \\\\
  I &= \frac 1 3 (R+G+B)\\\\
  S & = 
  \begin{cases}
  0 , &\text{if $I$ = 0}\\
  1 - {min \over I}, &\text{if $I \neq 0$}
  \end{cases} \\
  \end{aligned}
  $$

- 代码：
```c
// GLSL
vec3 RGBToHSI(vec3 color) {
	float minRGB = min(min(color.r, color.g), color.b);
    float maxRGB = max(max(color.r, color.g), color.b);
    float sum = maxRGB + minRGB;
    float chroma = maxRGB - minRGB;
    
    // Intensity;
    float intensity = dot(vec3(0.3333), color);
    vec3 hsi = vec3(0.0, 0.0, intensity);
    if (chroma == 0.0) return hsi;
    
    // Saturation
    hsi.y = intensity == 0.0 ? 0.0 : 1.0 - minRGB / intensity;
    
    // Hue 原来范围是 [0, 360), 这里默认输入的范围是 [0, 1]
    if (color.r == maxRGB) {
        hsi.x =  (color.g - color.b) / chroma / 6.0;         
    } else if (color.g == maxRGB) {
        hsi.x = ((color.b - color.r) / chroma + 2.0) / 6.0; 
    } else {
        hsi.x = ((color.r - color.g) / chroma + 4.0) / 6.0; 
    }
   
    // Optimize
    // hsi.x += 1.0 - step(0.0, hsi.x);
    if (hsi.x < 0.0) hsi.x += 1.0; 
    
    return hsi;
}
```

**HSI 转 RGB**

- 公式：
  如果 S (饱和度)  = 0，则颜色是非彩色的。H (色相)无意义， R = G = B = L (亮度)
  如果 S (饱和度) != 0，有如下公式

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 360), S \in [0,1], I \in [0,1]$
  ​
  $$
  \begin{aligned}
  H' &= {H \over 60}\\
  Z &= 1 - |H' \pmod 2 - 1| \\
  C &=  {3 \cdot S \cdot I \over 1 + Z} \\
  X &= C \cdot Z\\
  m &= (1 - S) \cdot I \\\\
  (R, G, B) &= 
  \begin{cases}
  (C + m, X + m,  m), &\text{if $0 \leq H' \leq 1$}\\
  (X + m, C + m,  m), &\text{if $1 \leq H' \leq 2$} \\
  (m, C + m,  X + m), &\text{if $2 \leq H' \leq 3$} \\
  (m, X + m,  C + m), &\text{if $3 \leq H' \leq 4$} \\
  (X + m, m,  C + m), &\text{if $4 \leq H' \leq 5$} \\
  (C + m, m,  X + m), &\text{if $5 \leq H' \lt 6$} \\
  \end{cases}\\
  \end{aligned}
  $$

- 代码：
```c
// GLSL
vec3 HSIToRGB(vec3 color) { 
    if (color.y == 0.0) return vec3(color.z); // Luminance
    
    float hue = color.x;
    hue *= 6.0;						   // Hue 默认范围是 [0, 1]
    float tmp = 1.0 - abs(mod(hue, 2.0) - 1.0);
    float chroma = 3.0 * color.y * color.z / (1.0 + tmp);
    float x = chroma * tmp;
    float m = (1 - chroma) * color.z;  // Lightness

    if (hue < 1.0){
        return vec3(chroma + m, x + m, m);
    } else if (hue < 2.0){
        return vec3(x + m, chroma + m, m);
    } else if (hue < 3.0){
    	return vec3(m, chroma + m, x + m);
    } else if (hue < 4.0){
        return vec3(m, x + m, chroma + m);        
    } else if (hue < 5.0){
        return vec3(x + m, m, chroma + m);
    } else {
        return vec3(chroma + m, m, x + m);
    }
}
```

### 3.5 RGB 与 YUV 

```c
///RGB [0,1] Y[0,1] U[-0.436,0.436] V[-0.615,0.615]
void RGB2YUV(CGFloat R, CGFloat G, CGFloat B,
             CGFloat *Y, CGFloat *U, CGFloat *V) {
    CLAMP_COLOR_VALUE(R);
    CLAMP_COLOR_VALUE(G);
    CLAMP_COLOR_VALUE(B);
    *Y =  0.298839 * R + 0.586811 * G + 0.114350 * B;
    *U = -0.147    * R - 0.289    * G + 0.436    * B + 0.5;
    *V =  0.615    * R - 0.515    * G - 0.100    * B + 0.5;
    
}

///RGB [0,1] Y[0,1] U[-0.436,0.436] V[-0.615,0.615]
void YUV2RGB(CGFloat Y, CGFloat U, CGFloat V,
             CGFloat *R, CGFloat *G, CGFloat *B) {
    U -= 0.5;
    V -= 0.5;
    *R = Y - 3.945707070708279e-05 * U + 1.1398279671717170825 * V;
    *G = Y - 0.3946101641414141437 * U - 0.5805003156565656797 * V;
    *B = Y + 2.0319996843434342537 * U - 4.813762626262513e-04 * V;
    CLAMP_COLOR_VALUE(*R);
    CLAMP_COLOR_VALUE(*G);
    CLAMP_COLOR_VALUE(*B);
}
```

### 3.6 RGB 与 YCbCr

```c
void RGB2YCbCr(CGFloat R, CGFloat G, CGFloat B,
               CGFloat *Y, CGFloat *Cb, CGFloat *Cr) {
    CLAMP_COLOR_VALUE(R);
    CLAMP_COLOR_VALUE(G);
    CLAMP_COLOR_VALUE(B);
    *Y  =  0.298839 * R + 0.586811 * G + 0.114350 * B;
    *Cb = -0.168737 * R - 0.331264 * G + 0.500000 * B + 0.5;
    *Cr =  0.500000 * R - 0.418688 * G - 0.081312 * B + 0.5;
}

void YCbCr2RGB(CGFloat Y, CGFloat Cb, CGFloat Cr,
               CGFloat *R, CGFloat *G, CGFloat *B) {
    Cb -= 0.5;
    Cr -= 0.5;
    *R = 0.99999999999914679361 * Y
       - 1.2188941887145875e-06 * Cb + 1.4019995886561440468 * Cr;
    *G = 0.99999975910502514331 * Y
       - 0.34413567816504303521 * Cb - 0.71413649331646789076 * Cr;
    *B = 1.00000124040004623180 * Y
       + 1.77200006607230409200 * Cb + 2.1453384174593273e-06 * Cr;
    CLAMP_COLOR_VALUE(*R);
    CLAMP_COLOR_VALUE(*G);
    CLAMP_COLOR_VALUE(*B);
}
```

### 3.7 更多色彩模型的转换

- [YY Color Convertor](https://github.com/ibireme/yy_color_convertor)

