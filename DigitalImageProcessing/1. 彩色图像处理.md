[TOC]

# 二、彩色图像处理

## 1. 颜色的特性

- 亮度：光的振幅，物体表面的反光率。实际上不能度量，色彩的强度（人眼对亮度的敏感 > 色彩）
- 色调：人感知的主要颜色
  补色：在色环上，与一个色调直接相对的另一端，用于增强图像暗区细节
- 饱和度：颜色的纯度，一种颜色混合白光的比例（100% 是无白光混合），物体反射的颜色，**饱和度高了色彩会鲜亮**
- 色度：色调 + 饱和度
  ​

## 2. 色彩模型

### 2.1 RGB 色彩模型

特点：适合色彩生成，适合硬件设备对于色彩的实现

加色混色模型：颜色混在一起亮度增大，**R**ed、**G**reen、**B**lue 三种颜色的取值范围是 [0, 255]

![](/Users/sun/Documents/CrushNote/DigitalImageProcessing/images/modelRGB.png)

### 2.2 CMY 和 CMYK 色彩模型 	 

特点：适合色彩生成，适合硬件设备对于色彩的实现

减色混色模型：颜色混在一起亮度降低，**C**yan (青)、**M**agenta (品红)、**Y**ellow(黄)、Blac**K**(黑)，加入黑色是因为打印时由品红、黄、青构成的黑色不够纯粹

![](/Users/sun/Documents/CrushNote/DigitalImageProcessing/images/modelCMYK.png)



### 2.3 HSL 和 HSV 色彩模型 

特点：适合色彩描述、电脑绘画、图像算法的处理，人能观察的色彩并不是由 RGB 三种颜色混合而成，而是取决于颜色的亮度、色调、饱和度

HSL 和 HSV 有相同的灰度定义，但在 饱和度 和 亮度的定义方面是不同的：

- 饱和度：
- 亮度：HSL 最大为 0.5，HSV 最大为 1

**H**ue：色相，决定什么颜色，对应 *红橙黄绿青蓝紫 红* 首尾相接的色相环值，取值范围 [0, 360)
**S**aturation：饱和度，决定颜色浓淡，一种颜色混合白光的比例（100% 是无白光混合），物体反射的颜色，**饱和度高了色彩会鲜亮**
**L**ightness/**L**uminance/**I**ntensity：亮度，光的振幅，物体表面的反光率
**V**alue/Brightness：明度，人们所感知到的色彩明暗度

明度和亮度：都决定照射在颜色上的白光有多亮，亮度与颜色的辐射能量有关，但能量高的颜色不一定明度高。例，蓝色的能量很高，但其明度却低 [more](https://en.wikipedia.org/wiki/HSL_and_HSV)

![](/Users/sun/Documents/CrushNote/DigitalImageProcessing/images/modelHSLV.png)



### 2.3 YUV 和 YCbCr 色彩模型

特点：适合电视系统，数码摄影点色彩生成和传输

- YUV：Y (亮度)、UV (色度)，欧洲电视系统色彩模型 PAL 制式 
- YCbCr：Y (亮度)、Cb (蓝色色度)、Cr (红色色度)，**YUV 的压缩和偏移版本**

## 3. 色彩模型间的互相转换
### 3.1 RGB 与 CMY

- 公式：假设所有彩色值都归一化到了 [0, 1] 的范围内
  ​
  $$
  \begin{bmatrix}
  C\\
  M\\
  Y
  \end{bmatrix}
  =
  \begin{bmatrix}
  1\\
  1\\
  1
  \end{bmatrix}
  - 
  \begin{bmatrix}
  R\\
  G\\
  B
  \end{bmatrix}
  $$



### 3.2 RGB 与 HSL 

**RGB 转 HSL**
- 公式：
  如果 R = G = B 时，颜色是非彩色的，H (色相) 无定义，H = S = 0
  max 是 R、G、B 中的最大值
  min  是 R、G、B 中的最小值

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 360), S \in [0,1], V \in [0,1]$
  ​
  $$
  \begin{aligned}

  H &= 
  \begin{cases}
  0, &\text{if max = min}\\
  60 \times {G - B \over max - min} + 0, &\text{if max = R  and G $\geq$ B} \\
  60 \times {G - B \over max - min} + 360, &\text{if max = R  and G $\lt$ B}\\
  60 \times {B - R \over max - min} + 120, &\text{if max = G}\\
  60 \times {R - G \over max - min} + 240, &\text{if max = B} \\
  \end{cases} \\\\
  L &= \frac 12(max + min) \\\\
  S & = 
  \begin{cases}
  0 , &\text{if max = min or L = 0}\\
  {max - min \over max + min} = {max - min \over 2L} , &\text{if $0 \lt L \leq \frac 12$}\\
  {max - min \over 2 - (max + min)} = {max - min \over 2 - 2L}  , &\text{if $L \gt \frac 12$}
  \end{cases} 
  \end{aligned}
  $$
  ​

- 代码：

  ```c
  // GLSL
  vec3 RGBToHSL(vec3 color) {
      float min = min(min(color.r, color.g), color.b);
      float max = max(max(color.r, color.g), color.b);
      float sum = max + min;
      float range = max - min;
      
  	// Luminance = 0.5 * sum;
      vec3 hsl = vec3(0.0, 0.0, 0.5 * sum);
   
      if (range == 0.0) return hsl; // R = G = B, 颜色是非彩色的 S = 0，这是色相无定义 H = 0

      // Saturation
      // Optimize
      // hsl.y = mix(range / (2.0 - sum), range / sum, step(hsl.z, 0.5));
      hsl.y = hsl.z < 0.5 ? range / sum : range / (2.0 - sum);
      
      // Hue 原来范围是 [0, 360), 这里默认输入的范围是 [0, 1]
      /** Optimize 
          vec3 comp;
          comp.rg = vec2(equal(rgb.rg, vec2(max)));
          float invertR = 1.0 - comp.r;       // 0 or 1
          comp.g *= invertR;                  // g = invertR * g
          comp.b  = invertR * (1.0 - comp.g); // b = invertR * invertG
          hsl.x = dot(comp, vec3((color.g - color.b) / range, (color.b - color.r) / range + 2.0, (color.r - color.g) / range + 4.0));
          hsl.x /= 6.0;
      */
      if (color.r == max)
          hsl.x = (color.g - color.b) / range / 6.0; 
      else if (color.g == max)
          hsl.x = (2.0 + (color.b - color.r) / range) / 6.0; 
      else if (color.b == max)
          hsl.x = (4.0 + (color.r - color.g) / range) / 6.0; 
  	
      // Normalize Hue
      // Optimize
      // hsl.x += 1.0 - step(0.0, hsl.x);
      if (hsl.x < 0.0) hsl.x += 1.0; 
      
      return hsl;
  }
  ```

**HSL 转 RGB**
- 公式：
  如果 S (饱和度)  = 0，则颜色是非彩色的。H (色相)无意义， R = G = B = L (亮度)
  如果 S (饱和度) != 0，有如下公式

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 1], S \in [0,1], V \in [0,1]$
  ​
  $$
  \begin{aligned}
  f_1 &=
  \begin{cases}
  L \times (1 + S) , &\text{if $L \lt \frac 12$}\\
  L + S - (L \times S) , &\text{if $L \geq \frac 12$}
  \end{cases}\\
  f_2 &= 2 \times L - f_1\\\\

  G(f_1, f_2, H) &= 
  \begin{cases}
  f_2 + 6 \times (f_1 - f_2) \times H, &\text{if $H \lt \frac 1 6$}\\
  f_1 , &\text{if $\frac 1 6 \leq H \lt \frac 1 2$} \\
  f_2 + 6 \times (f_1 - f_2) \times (\frac 2 3 - H) , &\text{if $\frac 1 2 \leq H \lt \frac 2 3$} \\
  f_2 , &\text{otherwise} \\
  \end{cases}\\\\

  R &= G(f_1, f_2, H + \frac 13) \\
  G &= G(f_1, f_2,H) \\
  B &= G(f_1, f_2,H - \frac 13) \\
  \end{aligned}
  $$

- 代码：
```c
// GLSL
float HueToRGB(float f1, float f2, float hue) {
    // Normalize hue
    // Optimize
    // hue += 1.0 - step(0.0, hue);
    // hue -= 1.0 - step(hue, 1.0);
    if (hue < 0.0) 
        hue += 1.0;
    else if (hue > 1.0)
        hue -= 1.0;
    
    float color = f2;
    if (6.0*hue < 1.0)
        color = f2 + 6.0 * (f1 - f2) *  hue;
    else if (2.0*hue < 1.0)
        color = f1;
    else if (3.0*hue < 2.0)
        color = f2 + 6.0 * (f1 - f2) * (2.0/3.0 - hue);
    
    return color;
}

vec3 HSLToRGB(vec3 hsl) {
    // Optimize
    /**
    float f1 = mix(hsl.z * (1.0 + hsl.y), hsl.z + hsl.y - hsl.z * hsl.y, step(0.5, hsl.z));
    float f2 = 2.0 * hsl.z - f1;
    float f1_f2 = f1 - f2;
    
    vec3 rgb = vec3(hsl.x + 0.333, hsl.x, hsl.x - 0.333);
    rgb = fract(rgb); //返回小数部分 normalize hue

    vec3 weight = step(6.0 * rgb, vec3(1.0));
    rgb = mix(rgb, f2 + 6.0 * f1_f2 * rgb, weight);
    
    vec3 weight_neg = 1.0 - weight;
    weight = weight_neg * step(rgb, vec3(0.5));
    rgb = mix(rgb, vec3(f1), weight);
    
    vec3 weight2_neg = weight_neg * (1.0 - weight);
    weight = weight2_neg * step(3.0 * rgb, vec3(2.0));
    rgb = mix(rgb, f2 + 6.0 * f1_f2 * (0.667 - rgb), weight);
    
    weight = weight2_neg * (1.0 - weight);
    rgb = mix(rgb, vec3(f2), weight);
    */
    vec3 rgb = vec3(hsl.z); // Luminance
    if (hsl.y != 0.0) {
        float f1 = hsl.z < 0.5 ? hsl.z * (1.0 + hsl.y) : hsl.z + hsl.y - hsl.y * hsl.z;
        float f2 = 2.0 * hsl.z - f1;
        rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));
        rgb.g = HueToRGB(f1, f2, hsl.x);
        rgb.b = HueToRGB(f1, f2, hsl.x - (1.0/3.0));
    }
    
    return rgb;
}
```

### 3.3 RGB 与 HSV 

**RGB 转 HSV**

- 公式：
  如果 R = G = B 时，颜色是非彩色的，H (色相) 无定义，H = S = 0
  max 是 R、G、B 中的最大值
  min  是 R、G、B 中的最小值

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 360), S \in [0,1], V \in [0,1]$

$$
\begin{aligned}

H &= 
\begin{cases}
0, &\text{if max = min}\\
60 \times {G - B \over max - min} + 0, &\text{if max = R  and G $\geq$ B} \\
60 \times {G - B \over max - min} + 360, &\text{if max = R  and G $\lt$ B}\\
60 \times {B - R \over max - min} + 120, &\text{if max = G}\\
60 \times {R - G \over max - min} + 240, &\text{if max = B} \\
\end{cases} \\\\
S & = 
\begin{cases}
0 , &\text{if max = 0}\\
{max - min \over max} = 1-{ min \over max} , &\text{if max $\neq 0$}
\end{cases} \\\\
V &= max
\end{aligned}
$$

- 代码：

 ```c
// GLSL
vec3 RGBToHSV(vec3 color) {
	float min = min(min(color.r, color.g), color.b);
    float max = max(max(color.r, color.g), color.b);
    float sum = max + min;
    float range = max - min;
    
    // V = max;
    vec3 hsv = vec3(0.0, 0.0, max);
    if (range == 0.0) return hsv;
    
    // Hue 原来范围是 [0, 360), 这里默认输入的范围是 [0, 1]
    /** Optimize 
        vec3 comp;
        comp.rg = vec2(equal(rgb.rg, vec2(max)));
        float invertR = 1.0 - comp.r;       // 0 or 1
        comp.g *= invertR;                  // g = invertR * g
        comp.b  = invertR * (1.0 - comp.g); // b = invertR * invertG
        hsv.x = dot(comp, vec3((color.g - color.b) / range, (color.b - color.r) / range + 2.0, (color.r - color.g) / range + 4.0));
        hsv.x /= 6.0;
    */
    if (color.r == max)
        hsv.x = (color.g - color.b) / range / 6.0; 
    else if (color.g == max)
        hsv.x = (2.0 + (color.b - color.r) / range) / 6.0; 
    else if (color.b == max)
        hsv.x = (4.0 + (color.r - color.g) / range) / 6.0; 
	
    // Normalize Hue
    // Optimize
    // hsv.x += 1.0 - step(0.0, hsv.x);
    if (hsv.x < 0.0) hsv.x += 1.0; 
    
    // Saturation
    hsv.y = max ? range / max : 0.0;
    
    return hsv;
}
 ```

**HSV 转 RGB**

- 公式：

  > **⌊ ⌋ Floor    向下取整：** 比自己小的最大整数，舍弃小数位
  > **⌈ ⌉ Ceiling 向上取整：** 比自己大的最小整数，有小数位就进 1
  > $\equiv$ ：
  >
  > 1. 恒等号 一般用于一些参变量恒为一个常数或恒定表达式时，总等于关系与变量无关。例 $f(x) \equiv k，f(x)$ 的值始终为 k 而与 x 无关
  > 2. 同余符号，例 $a \equiv b \pmod c$ ，a 和 b 分别除以 c 得到的余数相同

  $R \in [0,1], G \in [0,1], B \in [0,1]$
  $H \in [0, 360), S \in [0,1], V \in [0,1]$
  ​
  $$
  \begin{aligned}
  H_{level} &\equiv ⌊{H \over 60}⌋  \pmod 6\\
  \Delta H &= {H \over 60} - H_{level} \\
  f_1 &= V \times (1 - S) \\
  f_2 &= V \times (1 - S \times \Delta H) \\
  f_3 &= V \times (1 - S \times (1- \Delta H)) \\\\
  (R,G,B) &= 
  \begin{cases}
  (V, f_3, f_1), &\text{if $H_{level} = 0$} \\
  (f_2, V, f_1), &\text{if $H_{level} = 1$} \\
  (f_1, V, f_3), &\text{if $H_{level} = 2$} \\
  (f_1, f_2, V), &\text{if $H_{level} = 3$} \\
  (f_3, f_1, V), &\text{if $H_{level} = 4$} \\
  (V, f_1, f_2), &\text{if $H_{level} = 5$} 
  \end{cases}
  \end{aligned}
  $$

- 代码：
 ```c
// GLSL
vec3 HSVToRGB(vec3 color) { 
    vec3 rgb;
    if (color.y == 0.0) {
        rgb = vec3(color.z);
        return rgb;
    }
    
    // Hue 原来范围是 [0, 360), 这里默认输入的范围是 [0, 1]
    if (color.x == 1.0) color.x = 0.0;
    color.x *= 6.0; //((hue/60)/360)/6 == hue * 6
    float hueLevel = floor(color.x); 
    float hueDelta = color.x - hueLevel;
    float f1 = color.z * (1.0 - color.y);
    float f2 = color.z * (1.0 - color.y * hueDelta);
    float f3 = color.z * (1.0 - color.y * (1.0 - hueDelta));
    
    if (hueLevel == 0.0){
        rgb = vec3(color.z, f3, f1);
    } else if (hueLevel == 1.0){
        rgb = vec3(f2, color.z, f1);
    } else if (hueLevel == 2.0){
        rgb = vec3(f1, color.z, f3);
    } else if (hueLevel == 3.0){
        rgb = vec3(f1, f2, color.z);
    } else if (hueLevel == 4.0){
        rgb = vec3(f3, f1, color.z);
    } else {
        rgb = vec3(color.z, f1, f2);
    }
    
    return rgb;
}
 ```

### 3.4 RGB 与 YUV 

```c
///RGB [0,1] Y[0,1] U[-0.436,0.436] V[-0.615,0.615]
void RGB2YUV(CGFloat R, CGFloat G, CGFloat B,
             CGFloat *Y, CGFloat *U, CGFloat *V) {
    CLAMP_COLOR_VALUE(R);
    CLAMP_COLOR_VALUE(G);
    CLAMP_COLOR_VALUE(B);
    *Y =  0.298839 * R + 0.586811 * G + 0.114350 * B;
    *U = -0.147    * R - 0.289    * G + 0.436    * B + 0.5;
    *V =  0.615    * R - 0.515    * G - 0.100    * B + 0.5;
    
}

///RGB [0,1] Y[0,1] U[-0.436,0.436] V[-0.615,0.615]
void YUV2RGB(CGFloat Y, CGFloat U, CGFloat V,
             CGFloat *R, CGFloat *G, CGFloat *B) {
    U -= 0.5;
    V -= 0.5;
    *R = Y - 3.945707070708279e-05 * U + 1.1398279671717170825 * V;
    *G = Y - 0.3946101641414141437 * U - 0.5805003156565656797 * V;
    *B = Y + 2.0319996843434342537 * U - 4.813762626262513e-04 * V;
    CLAMP_COLOR_VALUE(*R);
    CLAMP_COLOR_VALUE(*G);
    CLAMP_COLOR_VALUE(*B);
}
```

### 3.5 RGB 与 YCbCr

```c
void RGB2YCbCr(CGFloat R, CGFloat G, CGFloat B,
               CGFloat *Y, CGFloat *Cb, CGFloat *Cr) {
    CLAMP_COLOR_VALUE(R);
    CLAMP_COLOR_VALUE(G);
    CLAMP_COLOR_VALUE(B);
    *Y  =  0.298839 * R + 0.586811 * G + 0.114350 * B;
    *Cb = -0.168737 * R - 0.331264 * G + 0.500000 * B + 0.5;
    *Cr =  0.500000 * R - 0.418688 * G - 0.081312 * B + 0.5;
}

void YCbCr2RGB(CGFloat Y, CGFloat Cb, CGFloat Cr,
               CGFloat *R, CGFloat *G, CGFloat *B) {
    Cb -= 0.5;
    Cr -= 0.5;
    *R = 0.99999999999914679361 * Y
       - 1.2188941887145875e-06 * Cb + 1.4019995886561440468 * Cr;
    *G = 0.99999975910502514331 * Y
       - 0.34413567816504303521 * Cb - 0.71413649331646789076 * Cr;
    *B = 1.00000124040004623180 * Y
       + 1.77200006607230409200 * Cb + 2.1453384174593273e-06 * Cr;
    CLAMP_COLOR_VALUE(*R);
    CLAMP_COLOR_VALUE(*G);
    CLAMP_COLOR_VALUE(*B);
}
```

### 3.6 更多色彩模型的转换

- [YY Color Convertor](https://github.com/ibireme/yy_color_convertor)

